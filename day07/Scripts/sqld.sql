SELECT DISTINCT TBP.PRODUCT_NAME
FROM TBL_ORDER TBO
JOIN TBL_PRODUCT TBP 
ON TBO.PRODUCT_ID = TBP.ID;

--	논리 연산자
--	1. BETWEEN A AND B: A부터 B까지
SELECT *
FROM (
	SELECT TBO.*, TBP.PRODUCT_BRAND, TBP.PRODUCT_PRICE 
	FROM TBL_ORDER TBO
	JOIN TBL_PRODUCT TBP 
	ON TBO.PRODUCT_ID = TBP.ID
)
WHERE PRODUCT_PRICE BETWEEN 100000 AND 300000;
--	같지않다. !=, <>
SELECT *
FROM (
	SELECT TBO.*, TBP.PRODUCT_BRAND, TBP.PRODUCT_PRICE 
	FROM TBL_ORDER TBO
	JOIN TBL_PRODUCT TBP 
	ON TBO.PRODUCT_ID = TBP.ID
)
WHERE PRODUCT_PRICE <> 119000;

--	NULL 관련 연산자
--	1) IS NULL: NULL인 데이터 / NULL이면  TRUE
--	2) IS NOT NULL : NULL이 아닌 데이터조회 / NULL이 아니면 TRUE
SELECT *
FROM (
	SELECT TBO.*, TBP.PRODUCT_BRAND, TBP.PRODUCT_PRICE 
	FROM TBL_ORDER TBO
	JOIN TBL_PRODUCT TBP 
	ON TBO.PRODUCT_ID = TBP.ID
)
WHERE ORDER_END_DATE IS NOT NULL;

--	문자열 함수
--	CONCAT(값, 값)
SELECT CONCAT('HELLO', 'WORLD')FROM DUAL;
SELECT 'HELLO'|| 'World' FROM DUAL;

--	LENGTHT(): 길이
SELECT LENGTH(CONCAT('HELLO', 'World')) FROM DUAL;

--	SUBSTR(): 문자열 추출 (ORACLE)
--	SUBSTRING() - MySQL

SELECT SUBSTR('오늘 점심 뭐 먹지?', 4, 4) FROM DUAL;

-- 더미 테이블 생성!
CREATE SEQUENCE SEQ_SQLD_PRODUCT;
CREATE TABLE TBL_SQLD_PRODUCT(
	ID NUMBER CONSTRAINT PK_SQLD_PRODUCT PRIMARY KEY,
	SQLD_PRODUCT_NAME VARCHAR2(255),
	SQLD_PRODUCT_PRICE NUMBER
);

INSERT INTO TBL_SQLD_PRODUCT
VALUES(SEQ_SQLD_PRODUCT.NEXTVAL, '지우개', 20000);
INSERT INTO TBL_SQLD_PRODUCT
VALUES(SEQ_SQLD_PRODUCT.NEXTVAL, '지우개', 20000);
INSERT INTO TBL_SQLD_PRODUCT
VALUES(SEQ_SQLD_PRODUCT.NEXTVAL, '키보드', 20000);
INSERT INTO TBL_SQLD_PRODUCT
VALUES(SEQ_SQLD_PRODUCT.NEXTVAL, '모니터', 30000);

CREATE SEQUENCE SEQ_SQLD_ORDER;
CREATE TABLE TBL_SQLD_ORDER(
	ID NUMBER CONSTRAINT PK_SQLD_ORDER PRIMARY KEY,
	SQLD_ORDER_NAME VARCHAR2(255),
	SQLD_PRODUCT_ID NUMBER,
	CONSTRAINT FK_SQLD_ORDER_SQLD_PRODUCT FOREIGN KEY(SQLD_PRODUCT_ID)
	REFERENCES TBL_SQLD_PRODUCT(ID)
);

INSERT INTO TBL_SQLD_ORDER
VALUES(SEQ_SQLD_ORDER.NEXTVAL, '문 앞 배송', 1);
INSERT INTO TBL_SQLD_ORDER
VALUES(SEQ_SQLD_ORDER.NEXTVAL, '직접 수령!', 2);
INSERT INTO TBL_SQLD_ORDER
VALUES(SEQ_SQLD_ORDER.NEXTVAL, '문 앞 배송', 1);
--	중복 연산자
--1) DISTINCT - 조회 결과의 중복을 제거함

--	합집합
--2) UNION: 중복을 제거하고, 두 컬럼 데이터 조회를 합친다.
SELECT SQLD_PRODUCT_NAME FROM TBL_SQLD_PRODUCT
UNION
SELECT SQLD_ORDER_NAME FROM TBL_SQLD_ORDER;

--3) UNION ALL: 중복을 제거하지 않고, 두 컬럼 데이터 조회를 합친다.
--	차집합
--4) MINUS : 중복 데이터를 삭제하고 남은 데이터만 출력

--	교집합
--5) INTERSECT

--	공집합

--==========================================================================================================
--	함수
--==========================================================================================================
--	문자열 함수
--	UPPER(): 대문자로 변경
SELECT UPPER('hello') FROM DUAL;
--	LOWER(): 소문자로 변경
SELECT LOWER('DATING') FROM DUAL;
--	TRIM(): 공백제거
SELECT TRIM('점 심 맛 있 게 먹 었 어?') FROM DUAL;

--	REPLACE(값, 찾을문자, 바꿀문자): 특정 문자를 치환
SELECT REPLACE('점 심 맛 있 게 먹 었 어?', ' ', '') FROM DUAL;

--	INSTR(): 특정 문자열의 위치 반환
SELECT INSTR('강사님 질문해도 될까요?', '해') FROM DUAL;

-- 날짜 함수
--	SYSDATE: 현재 날짜, 시, 분, 초
SELECT SYSDATE FROM DUAL;

--	CURRENT_DATE: 현재 날짜
SELECT CURRENT_DATE FROM DUAL;

--	현재 날짜를 기준으로 '월'을 추가, 
SELECT ADD_MONTHS(SYSDATE, 2) FROM DUAL;

-- 달 차이
-- MONTHS_BETWEEN()

SELECT MONTHS_BETWEEN(SYSDATE, '2024-07-12') FROM DUAL;  
-- 일 차이
SELECT (SYSDATE - TO_DATE('2025-09-15 11:15:00', 'YYYY-MM-DD HH24:MI:SS')) FROM DUAL;

-- 시 차이
SELECT (SYSDATE - TO_DATE('2025-09-18 11:15:00', 'YYYY-MM-DD HH24:MI:SS')) * 24 FROM DUAL;

-- 분 차이
SELECT (SYSDATE - TO_DATE('2025-09-18 11:15:00', 'YYYY-MM-DD HH24:MI:SS')) * 24 * 60 FROM DUAL;

-- 초 차이
SELECT (SYSDATE - TO_DATE('2025-09-18 11:15:00', 'YYYY-MM-DD HH24:MI:SS')) * 24 * 60 * 60 FROM DUAL;

--	 NEXT_DAY()
--	특정 날짜 이후의 지정된 요일을 반환		
SELECT NEXT_DAY(SYSDATE, '월요일') FROM

--	TRUNC()
SELECT * FROM TBL_INCOME;

--	ABS(): 절댓값을 반환
SELECT ABS(-100) FROM DUAL;

--	CEIL(): 올림
SELECT CEIL(3.14) FROM DUAL;

--	FLOOR(): 내림
SELECT FLOOR(3.9) FROM DUAL;

--	MOD(): 나머지
SELECT MOD(5, 2) FROM DUAL;

--	ROUND(): 반올림
--	POWER(): 거듭제곱
SELECT POWER(2, 8) FROM DUAL;

--	변환 함수
SELECT TO_NUMBER('12345.21') + 10 FROM DUAL;
SELECT TO_TIMESTAMP('2025-02-25 16:40:00', 'YYYY-MM-DD HH24:MI:SS') FROM DUAL;
SELECT TO_CHAR(SYSDATE, 'YYYY-MM-DD') FROM DUAL;
--SELECT TO_DATE()
SELECT CAST(10 AS VARCHAR2(255)) FROM DUAL;
SELECT CAST('10.5' AS NUMBER) FROM DUAL;
SELECT CAST('2025-02-23' AS DATE) FROM DUAL;

--★★★★★★★★★★★★★★★★NULL 함수★★★★★★★★★★★★★★★★★
--NVL(값1, 값2) : 첫 번째 값이 NULL이면 두 번째 값을 반환함
SELECT NVL(NULL, '대체 값') FROM DUAL;

-- 삼항이랑 비슷
--NVL2(값1, 값2, 값3) : 
SELECT NVL2(1, 'TRUE', 'FALSE') FROM DUAL;

--	COALESCE(값1, 값2, 값3, 값4, ...) : 값 중 NULL이 아닌 첫 번째 값을 반환
SELECT COALESCE(NULL, 0, NULL, 15) FROM DUAL;

--	NULLIF(값1, 값2) : 두 값이 같으면 NULL, 아니라면 첫 번째 값
SELECT NULLIF(NULL, NULL) FROM DUAL;

--	조건식
--	IS NULL : 널일 떼
--	IS NOT NULL : 널이 아닐때

-- CASE문
SELECT
	CASE BUYER_GENDER
		WHEN '남' THEN '남성고객'
		WHEN '여' THEN '여성고객'
		ELSE '중성고객'
	END AS "고객 성별"
FROM TBL_BUYER;

--	START WITH문
--	CONNECT BY PRIOR 부모와 자식 관계

CREATE SEQUENCE SEQ_PRODUCT;
CREATE TABLE TBL_PRODUCT(
	ID NUMBER CONSTRAINT PK_PRODUCT PRIMARY KEY,
	PRODUCT_NAME VARCHAR2(255),
	PRODUCT_PRICE NUMBER
);

INSERT INTO TBL_PRODUCT
VALUES(SEQ_PRODUCT.NEXTVAL, '마우스', 10000);
INSERT INTO TBL_PRODUCT
VALUES(SEQ_PRODUCT.NEXTVAL, '마우스', 30000);
INSERT INTO TBL_PRODUCT
VALUES(SEQ_PRODUCT.NEXTVAL, '마우스', 35000);
INSERT INTO TBL_PRODUCT

VALUES(SEQ_PRODUCT.NEXTVAL, '컴퓨터', 300000);
INSERT INTO TBL_PRODUCT
VALUES(SEQ_PRODUCT.NEXTVAL, '컴퓨터', 220000);

INSERT INTO TBL_PRODUCT
VALUES(SEQ_PRODUCT.NEXTVAL, '모니터', 40000);
INSERT INTO TBL_PRODUCT
VALUES(SEQ_PRODUCT.NEXTVAL, '모니터', 30000);

INSERT INTO TBL_PRODUCT
VALUES(SEQ_PRODUCT.NEXTVAL, '스피커', 55000);
INSERT INTO TBL_PRODUCT
VALUES(SEQ_PRODUCT.NEXTVAL, '스피커', 12000);
INSERT INTO TBL_PRODUCT
VALUES(SEQ_PRODUCT.NEXTVAL, '스피커', 30000);


SELECT 
	PRODUCT_NAME,
	PRODUCT_PRICE,
	RANK() OVER(PARTITION BY PRODUCT_NAME ORDER BY PRODUCT_PRICE) AS "RANK",
	DENSE_RANK() OVER(PARTITION BY PRODUCT_NAME ORDER BY PRODUCT_PRICE) AS "DENSE_RANK",
	ROW_NUMBER () OVER(ORDER BY PRODUCT_PRICE ) AS "ROW_NUMBER",
	SUM(PRODUCT_PRICE) OVER(PARTITION BY PRODUCT_NAME) AS "SUM"
FROM TBL_PRODUCT;

SELECT 
	PRODUCT_PRICE,
	LEAD(PRODUCT_PRICE, 1) OVER(ORDER BY PRODUCT_PRICE)AS "LEAD",
	LAG(PRODUCT_PRICE, 1) OVER(ORDER BY PRODUCT_PRICE)AS "LAG",
	FIRST_VALUE(PRODUCT_PRICE) OVER(ORDER BY PRODUCT_PRICE) AS "FIRST_VALUE",
	LAST_VALUE(PRODUCT_PRICE) OVER(
		ORDER BY PRODUCT_PRICE
		ROWS BETWEEN 1 PRECEDING AND 5 FOLLOWING
	) AS "LAST_VALUE",
	NTH_VALUE(PRODUCT_PRICE, 2) OVER(ORDER BY PRODUCT_PRICE)AS "NTH_VALUE",
	CUME_DIST() OVER(ORDER BY PRODUCT_PRICE) AS "NTH_VALUE",
	PERCENT_RANK() OVER(ORDER BY PRODUCT_PRICE) AS "PERCENT_RANK"
FROM TBL_PRODUCT;


--	집계 쿼리
--	ROLLUP()은 OVER()함수랑 같이 쓸 수 없다
SELECT PRODUCT_NAME, PRODUCT_PRICE,
SUM(PRODUCT_PRICE) OVER()
FROM TBL_PRODUCT
GROUP BY ROLLUP(PRODUCT_NAME, PRODUCT_PRICE);

SELECT PRODUCT_NAME, PRODUCT_PRICE,
SUM(PRODUCT_PRICE) OVER()
FROM TBL_PRODUCT
GROUP BY GROUPING SETS(
	(PRODUCT_NAME, PRODUCT_PRICE),
	PRODUCT_PRICE,
	()
);








